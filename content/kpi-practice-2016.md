---
title: "Кілька слів про КПІшну практику, або \"Як NodeJS'ер смикав Twitter API з Python'а\""
date: 2016-07-16T04:24:36.341211+00:00
draft: false
author: MaxymVlasov
email: m.vlasov@post.com
---

<div class="image-wrapper">
    <img src="/images/2016/08/1470174402_3317c88c7bc5440282eab3856290536e.jpg" class="post-image full-img">
</div>

Перш ніж перейти до суті проекту, розкажу передісторію. Якщо вам вона нецікава – переходьте відразу до [початку розробки](#console).



##  Передісторія



Все почалось ще ген зна коли. До мене дійшла інфа, що влітку 3-го курсу буде практика. Само собою, я про це не сильно хвилювався аж до травня цього року. Як бекендер на JS (специфічні смаки і все-таке :), на початках я збирався знайти практику на NodeJS, або хоча б підтягнути фронтенд. На горизонті майоріли світлі прапори Infopulse і EPAM, та до перших я так і не знайшов час податися, а до  других мені після вхідного тесту перехотілося йти, так що я не засмутився, як не пройшов.

Так як глашатаї ФІОТа рознесли, що документи про проходження практики не на кафедрі/НІІ приймають до 26-го травня (насправді ні – можна прийти й домовитись про принесення доків пізніше, або просто принести пізніше, проте вас можуть послати, навіть якщо вас півгрупи), так що я задався ціллю знайти собі нормальну і цікаву практику до Дня X.

На той момент лишалось 10 днів до "дедлайну подачі", тож я вирішив попитати знайомих старшокурсників, хто, як і де проходив практику, і чи не знають вони, де можна поJSсити. Так я вийшов на [WDC](http://wdc.org.ua/uk), що має офіс у 6-му корпусі, і [проект на NodeJS](https://github.com/kpi-wdc/).  

Тож, наступного дня, у вівторок, я зайшов з фразою "чув що у вас можна практику пройти на NodeJS" у 318-6, де секретар взяла мій контакти і... на тому все. Так як тиждень не було ніякої реакції, то я, для перестраховки, у суботу вирішив податись на [організатора івентів по DevOps](https://jobs.dou.ua/companies/devops-events/vacancies/27981/), аби розібратись [що ж це таке](https://goo.gl/Hqlsrb), та й в організації івентів маю досвід. Коли мені звідти таки передзвонили, я вже влаштувався на практику в WDC :)

Скажу вам, що нічого смішнішого, ніж написання розділу скілів у резюме івент-мейкера, я у цій сфері ще не робив. Серйозно, скіл володіння МС Офісом, гугло-доками і формами, відеодзвінки і т.д. – це ж треш якийсь)
<br>Остаточну версію можна [переглянути тут](https://vk.com/doc96849502_437515332).


Так як програмування мені імпонує трохи більше за організацію подій, я в понеділок (3 дні до дедлайну) вирішив навідатись в WDC і попитати щодо практики. Цього разу удача була на моїй стороні, бо на місці був і головний по практиці, і, як пізніше з’ясувалось, мій керівник з практики. NodeJS мені не дістався, бо усі проекти на ньому зав’язані на [Болдака](http://comsys.kpi.ua/ukrainian/teachers/50/) (це класнючий препод на кафедрі ОТ, ФІОТ), а він цього літа не хотів займатись даною справою.

Тож, мене відправили до [Путренка Віктора Валентиновича](http://ies.nau.edu.ua/index.php/uk/kafedra-zemlevporyadnykh-tekhnolohiy/kolektiv-kafedri?id=242) - дуже прошареної в географії людини. Після маленьких розпитів на тему "хто я такий, що вмію і чого хтів би навчитись", де я, між іншим, згадав, що влітку збираюсь повчити Python, мені була делегована доволі актуальна і цікава задача.




##  Задача 




Задача полягала в тому, щоб розібратись, чи працює в [QGIS](http://www.qgis.org/) (опенсорсна прога для візуалізації гео-даних) експериментальний плагін [twitter2qgis](https://plugins.qgis.org/plugins/geotweet/) ([github](https://github.com/Geolicious/geotweet)) по діставанню геотвітів (твіти з координатами) і зберіганню їх у [Shapefile](https://uk.wikipedia.org/wiki/Shapefile) (бажано), або у [GeoJSON](https://en.wikipedia.org/wiki/GeoJSON). Якщо не працюватиме – зробити свій, інакше – отримати іншу задачу.

Плагін виявився неробочим.

Наступним кроком був пошук будь-яких робочих опенсорс аналогів, які б працювали. Можливо я погано шукав, та вдалось знайти аж [1 консольну програму](https://github.com/Pinperepette/GeoTweet), що таки працювала! Правда, вона крешилася вже після захоплення одного-єдиного геотвіту, на моменті відображення координат у консольці. ¯\_(ツ)_/¯



##  Реалізація



###  Функціональність



В процесі розробки мені вдалося реалізувати наступну функціональність:

* Можливість підкидувати ключі авторизації до API твіттера через GUI і зберігати їх у файлі. В разі відсутності нових – підвантажувати попередні.
* **Дані для пошуку:**
    * Локація (полігон)
    * Ключові слова
    * Кількість твітів
    * Час, коли зупинити пошук
* **Виведення результатів:**
    * Метод пошуку:
        * В ріалтаймі (через Streaming API)
        * По всьому твіттеру  (REST API)
    * Кількість даних, що зберігаються у кожному твіті:
        * Всі
        * Мінімальна кількість (дата створення, текст твіту і координати) 
        * Жодних (тільки координати)
    * Формат даних на виході:
        * GeoJSON
        * Shapefile
        * У вигляді шару в QGIS
* **Help** до кожного пункту, що може викликати питання.

Станом на 16.07.16 це виглядає так:
![](/images/2016/07/1468636973_defde3b794f64cb2a9c3be04c8aeb0af.png)

Більше інформації по кожному з пунктів доступно в [документації проекту](https://github.com/MaxymVlasov/Tweets/wiki).



###  Розробка console-версії



Першим ділом я поринув у різнобарвний світ Twitter API,  де й завис на день. 

З хорошого: в документації є все. Або майже все. 

З поганого: треба прочитати [добіса тексту](https://dev.twitter.com/overview/api), інакше не зрозумієш, що відбувається. 

Наступного дня, все ще не до кінця відійшовши від апі твіттера, вирішив заюзати вибрані методи. Проте з 2012-го року напряму до них достукатись не можна – потрібні ключі авторизації. Постійний ключ можна отримати виконуючи [наступні інструкції](https://smashballoon.com/custom-twitter-feeds/docs/create-twitter-app/).

Крім того, для простого доступу до апі, знадобиться бібліотека, в моєму випадку – [tweepy](http://tweepy.readthedocs.io/). Хто ж хоче підтримку Python 3 – для них існує [twython](https://twython.readthedocs.io/en/latest/) і [трохи реалізації](https://github.com/webknjaz/twit-hist/blob/fc073b4414ad24790d5c6f8f99bcf3d077076e46/crawler3.py) на ньому.

На жаль, QGIS не вміє у 3-ій Python, так  що більшість подальших костилів будуть пов’язані з особливостями другої версії.

Спочатку я вирішив реалізувати звернення через метод [filter](https://dev.twitter.com/streaming/reference/post/statuses/filter) з Streaming API, що дозволило б колекціонувати твіти в реальному часі.


```
class listener(StreamListener):
    def on_data(self, data):      
        return True

    def on_error(self, status):
        print 'ERROR ' + str(status)
        if status == 420:
            print 'Exceed a limit requests connect to' \
                + 'the streaming API in a window of time (15min)'
            return False  # Returning False in on_data disconnects the stream

auth = OAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)
auth.set_access_token(ACCESS_TOKEN, ACCESS_TOKEN_SECRET)

stream = Stream(auth, listener())
stream.filter(locations=locations, track=keywords)
```
В `on_data` потрапляють всі твіти, що задовольняють задані в `stream.filter` умови. Додавання `locations` обмежує вхідний потік тільки геотвітами, що прискорює пошук останніх в ~20 разів.

Наступний крок – перетворення отримуваного json в geojson. 

Так, виглядає типовий geojson-файл:
```
{ "type": "FeatureCollection",
    "features": [
      { "type": "Feature",
        "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
        "properties": {"prop0": "value0"}
        },
       ]
     }
```
Так як Твіттер за один раз віддає 1 твіт, то перетворити його у geojson не складає проблем.

Для цього треба витягти геометрію за ключами з твіту і передати усю інформацію, що нас цікавить, у `"properties"`.
<br>Для полігонів координати лежать в ’["place"]["bounding_box"]["coordinates"]’, для точок – в `["geo"]["coordinates"]`.

Ніби все просто, та тут виявилося, що QGIS відображає  дані різних типів у різних шарах. Це ускладнює обробку інформації, бо замість1 таблиці з даними по твітах ви матимете 2-3 менших.

![](/images/2016/07/1468951467_12c16bab763f42138562f886f4aa7537.png)

Тож було прийнято рішення звести кожен полігон до точки у його центрі.

Далі постала задача зробити shapefile з наявного geojson. Для цього я використав бібліотеку [pyshp](https://pypi.python.org/pypi/pyshp), що вміє у конвертацію всього і вся у шейпфайли. Швидко розібратись, що до чого, допоміг [туторіал](https://glenbambrick.com/2016/01/09/csv-to-shapefile-with-pyshp/) по перетворенню CSV в Shapefile.


Паралельно з усім описаним відбувалися танці з бубном навколо кодування рядків у другому пайтоні. Кому цікаво, у що це вилилось – ось  [код консольної версії](https://github.com/MaxymVlasov/Tweets/tree/console).

І само собою, для гарного відображення в консольці додав функцію `print_time`, що відображає поточний стан речей.

![](/images/2016/07/1468954628_87ae7d9bcba84bed8acaa044c1231093.png)



###  Розробка GUI



До того моменту, як я прочитав у вікі, що QGIS – це  скорочення від Quantum GIS, то щиро вірив що Q означає Qt, бо на ньому  висить гуі як самого QGIS, так і плагінів до нього. Пояснити, чому саме Qt (і чому Qt4), буде простіше, якщо згадати, що до версії 0.8 QGIS вмів у плагіни тільки на C++.

Qt раніше не використовував, а ставити Qt Designer заради такого маленького плагіна мені здалось оверкілом. До того ж, я мав у своєму розпорядженні інтерфейс twitter2gis!

![](/images/2016/07/1468636963_a3b069060cdb4c5fa67c5be0da6df1ac.png)

Так, він незрозумілий і абсолютно не інтуїтивний, проте це вже щось.

Згенерував собі чистий додаток за допомогою [QGIS plugin creator](http://www.dimitrisk.gr/qgis/creator/) і підкинув в нього .ui файл  twitter2gis, який складається з одного лиш xml.

Першим ділом рефакторнув xml, що його 100% Qt Designer згенерував, бо нормальні [люди код так не пишуть](https://pp.vk.me/c633930/v633930502/338b4/dlkKZBtKA5I.jpg).

Потім рефакторнув ще раз, і ще раз.

Заліз у документацію, зрозумів що вона взагалі ніяк не розрахована на пряме редагування xml і, замість того, щоб поставити клятий Qt Designer, я почав експерементувати. Практика, все ж!

Наприклад, все, що в доках Qt починається на `set`, має одноіменний аналог в xml, тільки вже без `set`:
`setText(const QString &)` в класі [QLabel](http://doc.qt.io/qt-4.8/qlabel.html#text-prop), аналогічно
```
<widget class="QLabel" name="label">
  <property name="text">
    <string></string>
  </property>
</widget>
```


Далі понавішував усіляких фінтєфлюшечок і розбив на категорії. Після декількох годин пересовування на 3 пікселя кнопочок, я був задоволений результатом. Отримав наступне:

![](/images/2016/07/1468636973_defde3b794f64cb2a9c3be04c8aeb0af.png)



###  Об’єднання і допилювання



Наступним етапом стало об’єднання консольного коду і графічного інтерфейсу. 

Потрібно помістити код в `if result == 1:`, і тоді він виконуватиметься при натиснені "ОК" в GUI. Але так як ідея зміщувати весь основний код – не з розумних, і методом тику було встановлено, що `def run` працює у якомусь циклі (інакше як воно `if result == 1` вчасно ловить), я вирішив оброблювати протилежну ситуацію:
```
if not result:
    return False
```

Перемістивши код під `if`, запустив плагін на виконання і... QGIS завис до моменту закінчення роботи плагіну. Це Вирішилося додаванням параметра `async=True` в streamAPI() tweepy.

Далі я захотів прогрес-бар, як в geotweet.
![](/images/2016/07/1469756850_59060105fe324bacbba80ec49f6adf4b.png)
Ну що ж, я його зробив (рерайтинг:)). Тільки виникло одне АЛЕ: QGIS в синхронному режимі роботи плагіна зависає і не виводить повідомлень до завершення виконання, а в асинхронному закривається після першого графічного повідомлення. Це нікуди не годиться.

Тож я звернув увагу на консольні повідомлення.

За замовчуванням ця панель логів прихована. Та в неті є хак-рецепт по її примусовому відкриттю:
```
logDock = self.iface.mainWindow().findChild(QDockWidget, 'MessageLog')
logDock.show()
```

Тож, при запуску плагіна на виконання, вискакує така панелька:
![](/images/2016/07/1469757010_d0bf17f7cb07475483f60ebf427be536.png)
В ній через кожних 50 запитів (~щосекунди) виводиться поточний стан справ, і, що головне, в той же час можна паралельно працювати в QGIS.



##  Плани на майбутнє



Допилити плагін, а саме:
* Додати пошук через REST API (зараз тільки через Streaming API)
* Додати тести по навантаженню на систему кожною конфігурацією та іншу документацію
* Виводити в консоль QGIS усі помилки (python і т.д.)
* Зробити повноцінну консольну версію
* Зробити валідатор даних у geojson. Від виконуватиме перевірки і перетворення отриманих даних у валідний geojson в разі несанкціонованого закриття програми.

Репозиторій [доступний тут](https://github.com/MaxymVlasov/Tweets). Наразі там 2 гілки: сам плагін (master) і зачатки консольної версії.

Конструктивна критика коду і стилю (з опором на стайлгайди) – вітається)

Tags: python, qt, qgis, літня практика, КПІ, WDC

